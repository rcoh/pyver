\documentclass{article}[12pt]
\usepackage{fullpage}
\usepackage{setspace}
\usepackage{minted}
\author{Russell Cohen}
\title{Pyver: \\ A Python Static Analyzer Written in Haskell}
\date{\today}
\begin{document}
\renewcommand{\theFancyVerbLine}{
      \sffamily\textcolor[rgb]{0.5,0.5,0.5}{\scriptsize\arabic{FancyVerbLine}}}

\maketitle
\section{Motivation}

\subsection{Compiled vs. Interpreted Languages}
\doublespacing

Python is an extremely widely used programming language; it's utilized everywhere -- from
introductory computer science courses to production web sites to scientific computing. Its strength
lies in its flexibility, readability and simplicity. In order to facilitate these features, Python
is a dynamic language that is interpreted at runtime. While this enables much of it's it's
flexibility, it also invites a class of potential programming errors to sneak into one's code that
would be quickly detected and fixed in compiled languages.

When writing software, their are two classes of errors that occur: logical errors in a semantically correct program and
errors that violate the semantics of the programming language. The study of detecting logical errors has been
increasing with the development of self-proving languages such as Coq and Algol, but remains a somewhat open problem.
Semantic errors, on the other hand, are well understood. Compilers for static languages can reason about these
errors at compile time and won't produce a runnable binary until the programmer fixes the errors. Python, since it isn't
compiled, lacks these protections.

In general, the programmer wants to discover errors as quickly as possible. The sooner that the
error is found, the sooner the programmer can investigate the problem, attempt to fix it, and
continue their development process. Compiled languages detect semantic errors at the compile phase
-- before the program is even run. This increases the time before the program can be run, but it
\emph{guarantees} that program is free from semantic errors. Languages like Java, C++, and Haskell
fall into this category. Once a Java program is compiled, the compiled binary is guaranteed to be
free from type errors provided that the code avoids certain unsafe operations.
Figure~\ref{fig:csemanticerror} is an example of a semantic error that would be caught by the
compiler in the \texttt{C} programming language. 

\begin{figure} \begin{minted}{c} 
    struct Student { 
      int grade; 
    } 
    Student s; 
    int atten = s.attendance; // Semantic error -- Student has no field attendance 
  \end{minted} 
  \caption{A semantic error in the C Programming Language. This is
    detected by the compiler at compile time.} 
  \label{fig:csemanticerror}
\end{figure}

\begin{figure}
    \begin{minted}{python}
        class Student:
          attendance = 100

        s = Student()
        atten = s.attendance # Runtime type error
    \end{minted}
    \caption{A semantic error in Python isn't caught until runtime which could an occur and
    arbitrary amount of time after starting the program.}
    \label{fig:pythonsemanticerror}
\end{figure}

Runtime-interpreted languages, however, lack these guarantees. Rather than being compiled,
interpreted languages are evaluated line by line as the interpreter reaches the line in question.
Interpreted languages can be extremely flexible and allow programmers large amounts of freedom in
how they use language constructs. However, these languages make weak guarantees on the programs they
run. In Python, for example, the interpreter only checks that the program is syntactically valid
before running it. Figure~\ref{fig:pythonsemanticerror} gives an example of a semantic error in
Python which will not be caught until runtime. These present an entire class errors that can only be
discovered when the interpreter attempts to execute the offending statement. In short-running
programs, the debug time can be equivalent to a compiled language; the programmer runs her code and
the Python interpreter immediately outputs a type error. If instead, the errant statement doesn't
get executed for several hours after the program begins, the programmer has now wasted hours waiting
for the program that could have been saved, had she been notified of a type error at
initially. 

Late error detection also poses problems when using Python in a web application or other target with rarely executed
code paths -- if a type error is accidentally introduced in a seldom used code path, the error won't be discovered until
much later when an unsuspecting user hits the code path and is presented with an error. Ideally, the programmer could have been
alerted of this error before deploying the code. If the website had been written in a statically typed language, the
error would have been caught at compile time and fixed. Instead, it managed to make it all the way to an end user.

\section{Why Doesn't Python Include Semantic Checking?}
In light of the problems with dynamic languages such as Python, one could wonder why Python is missing
static checking of types. The problem lies in the flexibility of Python's type system. 

Before investigating the flexibility of the type system, let's clarify exactly what we mean when we
discuss the type of a variable. Intuitively, it's any property where changing it could cause a type
error. In Python, this encompasses the fields an object has and it's underlying core type.
Figure~\ref{fig:pythontypes} details several different types in Python.

\begin{figure}
    \begin{minted}{python}
        a = [] # A has list type
        b = 5 # B has int type
        c = a + b # This is a runtime type error

        # class X has one integer field, a
        class X:
          a = 5

        x_inst = X() # x_inst has one integer field a

        # This would be a runtime type error:
        # val = x_inst.b
        
        # Add another field to the instance
        x_inst.b = True # x_inst is now A DIFFERENT TYPE. 
        
        # Now, not a type error:
        val = x_inst.b
    \end{minted}
    \caption{Examples of types in Python. Types can either be a core type or instance type. Instance
    types vary in the fields they define}
    \label{fig:pythontypes}
\end{figure}

In Python, variables are dynamically typed. This implies that the type of a variable can change as
the program proceeds. Contrast this with Java and other statically typed languages where a variable
is born with a type that never changes. Since Python types can change, it stands to reason that if
we wanted to, we could encode information in the type of a variable rather than using the value. You
could write an entire program that worked by only modifying the types of variables!  Although I will
not prove it formally, it should be relatively obvious given this information that the only perfect
type verification system for Python is to run the program.  After you've run the program, you have
defeated the purpose your verification system (since running and waiting for the program was what we
were trying to avoid in the first place).

Though a perfect bounded-time simulation of the type system is impossible, it is possible the create
a system approximates type information instead. Ideally, rather than running in an undecidable
amount of time, our type analyzer will run in time linear in the number of statements in the
program. From this, it becomes clear that we can't allow our analysis to backtrack -- it can only
perform a constant amount of work per statement. 

Thus, we must approximate control flow that would cause our program to loop, as a loop removes the
bound of constant work per statement. There are two primary elements of control flow that would
cause our program to loop on itself: looped control flow and recursion. Handling looped control is
actually quite straightforward: simply ignore it -- execute the loop body as if the control loop
control structures didn't exist, and start looping variables at their initial type.
Figure~\ref{fig:ignoreloops} gives an example where no information is lost by executing the loop
body only once. Unfortunately, it's very easy to create examples where this isn't correct --
Figure~\ref{fig:cantignoreloops} shows an example where our inference cannot produce the correct
result.

\begin{figure}
    \begin{minted}{python}
      def count_occurrences(list, item_to_count):
          count = 0
          for item in list_of_data:
            if item == item_to_count: 
              count += 1
          return count
      
      some_strings = ['6.01', '6.02', '6.035', '6.UAP', '6.UAT', '6.UAP']
      count = count_occurrences(some_strings)

  \end{minted}
  \caption{A loop to count the occurrences of an item in a list. In this loop, the types of the
      variables can be fully inferred by one evaluation of the loop.
  }
  \label{fig:ignoreloops}
\end{figure}


\begin{figure}
    \begin{minted}{python}
        class Empty:
            pass

        e = Empty()
        for i in range(10):
            setattr(e, "prop" + str(i), True) # e.prop1 = True, e.prop2 = True, etc.

        print e.prop5
        # The type of e now is directly dependent on the number of loop iterations
    \end{minted}
    \caption{Performing a silly computation with types. Without fully evaluating the loop, there is now
        way that we could determine the type of \texttt{e}. If we evaluated once, we would infer
        \texttt{e} to have only one parameter, \texttt{prop1}. However, \texttt{e} will have 10
        properties set.  
     } 
     \label{fig:cantignoreloops}
 \end{figure}
When our analyzer reaches it loop, it registers the type information it can infer about the looping
variables and it evaluates the body of loop a single time. Then, it makes the simplifying (and
potentially incorrect) assumption that though the values may change in subsequent executions of the
loop, the type information will not.

The more complex case to handle is that of recursion -- recall that iteration can even be simulated
by recursive functions. We handle recursive functions by first detecting that a function is
recursive (by tracking the function graph), and then applying an approximation. We approximate
recursive functions by assuming (possibly incorrectly) that the concrete type returned by the
function is the actual return type of the function. More precise details on handling of functions
will follow.

\section{High Level Design} Our static analyzer works by creating an abstract representation of
Python programs and simulating their execution within this abstract space. Our abstract
representation decomposes into two components: the type system, and the action system. The type
system fully represents our view into the state of a Python program. To create the type system, we
translate each line of code into a series of composable actions.  These actions are then applied to
the program state, yielding a new state. The system is designed to find two types of problems in
code: type errors which would cause the program to halt in an unexpected way, and accidental types
that will not halt the program but will almost certainly cause unexpected behavior to occur. The
detection of accidental but non-fatal errors is a currently investigated field; the Clang C/C++
compiler presents a productionized example of this practice and is under current active development.

\subsection{Handling of Errors}

Error handling must be done with care to create a verification system that is useful in practice.
For example, if the analyzer stops running on reaching a potential error, it's of limited use,
especially if the error was a false positive. In our system, errors are actually included in the
resulting type information. Once the analysis is complete, we can collect all variables whose type
is inferenced to be in error and present them coherently to the user. For example, consider the
following short Python program:

\begin{minted}{python}
    x = a
\end{minted}
In this program, \verb=x= is assigned to \verb=a=, but \verb=a= isn't defined. In our system, the type of
\verb=x= would then become \verb=NotDefined 'a'=. Any further computations that used \verb=x= would
have this value propagated.

This behavior is identical for other classic type mistakes, eg.:
\begin{minted}{python}
    a = 5
    x = a[1] # IdentifierNotSubscriptable 'a'
\end{minted}
In this example, we assign \verb=x= the type \texttt{IdentifierNotSubscriptable} indicating that the attempt to
list-index against \texttt{a} was invalid.

Along with being propagated through the program state, we also maintain a list of errors that have been detected as the
program executes. This is done for convenience and to prevent the potential snowball effect from creating an overwhelming number of
errors presented to the user.

\subsection{Handling Of Warnings}
Since Pyver does a reasonable job a producing a full picture of the types used in a program, it
can also detect usages of types that are probably unintentional. We leverage this knowledge to warn
programmers about suspect code to limit time spent debugging. To produce warnings, we have added two
heuristics. In a complete system, many more would
help to catch bugs in a wider range of programs. Pyver can currently produce the following warnings:

\begin{itemize}
    \item \textbf{Differing core types surrounding \texttt{==}}: In Python, an integer type will never
          equal a list type will never equal a set type will never equal a dictionary type will
          never equal a string type. This only applies to the core types, however, since their
          equality method cannot be overridden in user defined types. This has one notable edge case: \texttt{True} and
          \texttt{False} in
          Python are not really their own types -- \texttt{True} is an alias for 1 and
          \texttt{False} is an alias for 0. Therefore, comparing integers to booleans is a
          reasonable thing to do (although a bit opaque to the reader).

      \item \textbf{Using a value from a function that returns only \texttt{NoneType}}: While functions can often
          return \texttt{NoneType} validly in some cases, our system will detect a function that can only
          return None in cases where there are no return statements. Using the value in a function
          without a return statement is almost certainly incorrect.
\end{itemize}

Python certainly contains many more of these type ``gotchas'', and they could be incorporated into a
productionized version of this system.

\subsection{Representation of Type System} 

Loosely speaking, the Type System represents the noun of our inference system. The type system has
the following representation:
\emph{This listing currently represents types in the Haskell style which may be a bit unfamiliar to some readers. A
pending TODO is to pick a more widely understood format.}
\begin{minted}{haskell}
  PyType = 
      -- Core Types
      PyInt | 
      PyBool | 
      PyChar |
      PyStr  |
      NoneType |
      FunctionType { name :: String, args :: [PyType], body :: [Action] } | 

      -- Core datastructures
      PyList PyType | 
      PySet  PyType |
      PyDict PyType PyType | 


      -- Normal classes / objects
      ComplexType { String => PyType } | 

      UnionType [PyType] | 
      Identity |
      Unknown |

      AttributeNotFound String |
      IdentifierNotFound String |
      ObjectNotSubscriptable String |
      ObjectNotCallable String 
\end{minted}

This encompasses types for the core Python primitives (ints, bools, strings), the standard
parameterized types (lists, sets, and dictionaries). The \texttt{UnionType} allows us to represent expressions that may be several different types at a given program point, for example, in code like the following:

\begin{minted}{python}
    a = [1, False, []]
    b = a[math.randint(2)]
\end{minted}

Our system inferences \verb=b= to be a \verb=UnionType [PyInt, PyBool, PyList Unknown]=.

Union types can also be created when types differ at a branch:
\begin{minted}{python}
    class Student:
      grade = 100

    s_attend_class = math.randbool()
    s = Student()
    if s_attended_class:
      s.attendance = 100
\end{minted}
At the end of this code path, our system infers the \texttt{s} is the union of an object with an attendance field and an
object with just a student field. Further operations will be tried against both representations. Full details on the
semantics of union types are discussed later.

\verb=ComplexType=, which contains a map from \verb=String= to \verb=PyType= is used to represent
classes composed of the other core types. For example:
\begin{minted}{python}
    class Student:
      grade = 95 
      enrolled = True
\end{minted}

Our system inferences \verb=Student= to be a 
\verb=ComplexType { grade -> PyInt, enrolled -> PyBool }=

The identity type is used to represent fields which have the identical type of their parent. We use
this constructor field of classes. For example, returning the student example, the actual
representation would be
\verb=ComplexType { grade -> PyInt, enrolled -> PyBool, __init__ -> Identity }=
(\verb=__init__= is the constructor method in Python).

Unknown is used when the type of a variable cannot be knowable at a code position, for example:
\begin{minted}{python}
    a = []
\end{minted}
Our system inferences \verb=a= to be a \verb=ListType Unknown=.

The remaining types are generated when the action that is applied to a type is illegal to apply (for
example applying \verb=getSubscript= to an \verb=PyType=

\subsection{Representation of the action system}
The action system represents the verbs of our abstract representation. The actions correspond to
actions that are built into the Python language. Python programs are
deconstructed into the following actions:
\emph{This listing should also be rewritten}
\begin{verbatim}
  Action =
    Assignment   lhsFunc :: (PyType -> PyType -> PyType), rhs :: PyType
    GetAttribute item :: String, base_object :: PyType 
    SetAttribute item :: String, attr_value :: PyType, base_object :: PyType 
    DeleteAttribute item :: String, base_object :: PyType
    GetSubscript index ::  PyType,  base_object :: PyType 
    SetSubscript index ::  PyType, value :: PyType, base_object :: PyType 
    DeleteSubscript index ::  PyType, base_object :: PyType 

    ArithPlus left :: PyType, right :: PyType 
    ArithMinus left :: PyType, right :: PyType 
    ArithTimes left :: PyType, right :: PyType
    ArithDiv left :: PyType, right :: PyType 

    ArithPlusEqual left :: PyType, right :: PyType
    ArithMinusEqual left :: PyType, right :: PyType

    ArithCheckEqual left :: PyType, right :: PyType

    FunctionCall callable :: PyType, args :: [PyType]

    LoopFor  looping_scope :: PyType, body :: [Action]
    LoopWhile  looping_scope :: PyType, body :: [Action]
\end{verbatim}

These operations are generalized in that they operate identically not only on concrete types, but
also on scopes. All Actions are ``Applyable''. When applied, all Actions produce a new PyType. The apply, combined with
the lazyness of Haskell allows us to nest actions -- we can nest one action within another by applying it, which
produces a new PyType.

Below, we will summarize the Python code that leads to these actions.

\verb=GetAttribute= is the ``dot'' operator as well as simply looking up a variable in a scope. When
applied, GetAttribute yields the type of the resulting attribute.
Accessing in a scope:
\begin{minted}{python}
    a = 5
    x = a # GetAttribute ``a'' ProgramScope
\end{minted}

Accessing in a class:
\begin{minted}{python}
    class Student:
      grade = 95

    s = Student()
    grade = s.grade #GetAttribute ``grade'' s
\end{minted}

Similarly, \verb=SetAttribute= sets class attributes as well as variables into scopes. When applied,
SetAttribute returns the \verb=base_object= with the new attribute added.

\begin{minted}{python}
    a = 5 #SetAttribute {item: 'a',  attr_value: PyInt, base_object : ProgramScope}
    class Student:
      grade = 100

    s = Student()
    s.attendance = .99 # SetAttribute {item: 'attendance':, attr_value: PyFloat, base_object: s}
\end{minted}

\verb=GetSubscript= and \verb=SetSubscript= are the parallel to \verb=GetAttribute= and
\verb=SetAttribute=, but the subscript operator (\verb=[]=)

\begin{minted}{python}
    a = [1, 2, 3]
    b = a[1] # GetSubscript { index :: PyInt, base_object :: a }
    a[2] = b # SetSubscript { index :: PyInt, value : : PyInt, base_object :: PyList Int }
\end{minted}

\section{Implementation Details}

Under the hood, the analyzer is implemented in Haskell. Haskell was chosen because of its type
safety, functional properties, and the presence of Python parser in the standard library. 

The entire analysis is implemented as one large fold. The program is processed statement by statement. Each
statement produces a new program state, which is given to the next statement.

\subsection{Handling Mutable State}
Representing a language like Python that relies heavily on shared mutable state in Haskell is
tricky. We handle it by using value numbering. All values that should be kept identical share the
same value-number. Inside the actual tree, the values are not stored, but instead, their value
numbers. When something is modified, it is modified in the map from value number to \verb=PyType=.
That way, all attributes which should share the same type in the Python program are also modified.
We see this in Figure~\ref{fig:mutablestate}.

\begin{figure}
\begin{minted}{python}
    class Student:
      grade = 95
    student1 = Student()
    student2 = student1
    student2.attendance = 99
    # student1 should now also have an attendance attribute
\end{minted}
\caption{Reference equality of two objects links their types}
\label{fig:mutablestate}
\end{figure}

\subsection{Handling User Supplied ``Magic Methods''}
One of Python's most powerful features is the ability for users to override so called ``magic methods''. These methods,
started and followed by double underscores allow the programmer to override seemingly built-in language features for
their own datatypes. For example, if you define an \texttt{\_\_getitem\_\_} on your class, your class will support list
indexing.
\begin{figure}
    \begin{minted}{python}
        class Funky(object):
            def __getitem__(self, index):
                return index

        f = Funky()
        print f["Hello world"] # prints "Hello World"
    \end{minted}
    \caption{Python allows you to override the behavior of different operatorsfor your own classes}
    \label{fig:magicmethods}
\end{figure}

Pyver supports magic methods by attempting to search for an existing use-supplied definition of the appropriate magic
method matching the language construct. For example, in Figure~\ref{fig:magicmethods}, \texttt{f} is a \texttt{ComplexType}, so upon seeing a
\texttt{GetItem} action, it searches for an existing \texttt{\_\_getitem\_\_} to invoke.
  
Each action that Pyver supports maps one-to-one with a ``magic method''. Currently Pyver does not support all magic
methods (only the most common) but could be easily improved to support the full set.

\subsection{Representation of Union Types}
Pyver's representation of union types is a heuristic designed to give more accurate results in undecidable
scenarios. Though this is one representation, more accurate representations almost certainly exist. At their core, union types are simply a list of other types. A variable typed with a union type may be any one
of the types in the set. The rules of union types in Pyver are as follows:
\begin{enumerate}
  \item A union type of a single type is collapsed into a concrete type
  \item When adding a new type to a union type: 
      \begin{itemize}
          \item If it is a ComplexType (standard python class), merge it in with all existing ComplexTypes in the union if
              there is no overlap. (Overlap is defined as fields that share the same name, but differ in type). If there
              is overlap, create a second ComplexType. Merge any identical or non-overlapping ComplexTypes if possible.
          \item Unions have set semantics: if a type is identical to an existing type in the union,
              discard it -- it does
              not enter the union twice.
          \item A union cannot contain Unknown -- Unknown indicates no knowledge of the type, as is the case in an empty
              list. Since a union must contain 2 or more types, it can never contain Unknown.
      \end{itemize}
  \item When actions are applied to a union type, they are mapped over all of the child types in the union. This
      produces a new union with the results, some of which may be error types. The rules for merging are
      applied to the new result before producing a new type.
\end{enumerate}



\section{Analysis Results}

Here, we will present several buggy programs and the results of their analysis.

One of the most powerful features of the analysis system is it's ability to detect mistakes that are
not actually type errors. For example, in the Figure~\ref{fig:guessnum}, the analysis system infers that the
user equality checks two fundamentally different types. Since this will always produce false, the
system warns that this could be an error.

\begin{figure}
    \begin{minted}{python}
        my_number = 75 # Inferred PyInt
        while 1:
            guess = raw_input("What's your guess?") #Inferred String
            # WARNING: ArithCheckEqual with type String and Int will never be equal 
            if guess == my_number:
                print "Correct"
                break
            elif guess < my_number:
                print "Go higher"
            else:
                print "Go lower"
    \end{minted}
    \caption{Guess my number game. This code will produce a warning because the analyzer correctly
        detects the lack of a conversion of \texttt{raw\_input} \texttt{string} to \texttt{int}.}
    \label{fig:guessnum}
\end{figure}

The system can also detect classic python type errors such as trying to append an integer to a list
with \texttt{+=} instead of \texttt{append}. We see this in Figure~\ref{fig:findprimes}.
\begin{figure}
    \begin{minted}{python}
        # Program to collect collect primes
        def is_prime(x):
          for i in range(2, x - 1):
            if x % i == 0:
              return False
          return True
        
        primes = []
        look_until = 10000
        for i in xrange(look_until):
          if is_prime(i):
            # i is inferred Int
            # primes is inferred List [Unknown]

            # ArithPlusEqualsInvalidError: Cannot append int to list. 
            # Only iterable objects can be appended to lists.
            primes += i
    \end{minted}
    \caption{A buggy program to find prime numbers}
    \label{fig:findprimes}
\end{figure}

The system can also detect missing return statements in functions, as we see in
Figure~\ref{fig:noreturn}.
\begin{figure}
    \begin{minted}{python}
        def filter_odd(inp):
          ret = []
          for i in inp:
            if i % 2 == 1:
              ret.append(i)
          # Does not return ret

        inp_list = [1, 5, 123, 1231, 32, 63, 412, 2461512, 2354656]

        # odds is inferred to be NoneType
        # WARNING: Function produces NoneType and is used in assignment. Missing return?
        odds = filter_odd(inp_list)
        # ERROR: NoneType can not be iterated over
        for num in odds:
          print num
    
    \end{minted}
    \caption{A silly program to filter odd numbers from a list}
    \label{fig:noreturn}
\end{figure}
\end{document}
